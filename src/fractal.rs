/*
    This file is part of grunge, a coherent noise generation library.
*/

//! Types for generating noise related to fractal patterns.
//!
//! These are the main coherent noise implementations. PinkNoise and BillowNoise
//! in particular can be traced back to ideas used by Ken Perlin in
//! [Tron](http://en.wikipedia.org/wiki/Tron), and later demonstrated when he
//! introduced the first "noise" function to industry in 1985. They were
//! used to create water, cloud and fire textures, among other things.
//! RidgedMultifractalNoise originates with F. Kenton Musgrave, who draws
//! heavily on Perlin's noise function but adds his own touches.
//!
//! <div style="margin: 0 auto; display: block; text-align: center">
//!     <img src="../static/pink.png" alt="PinkNoise">
//!     <img src="../static/billow.png" alt="BillowNoise">
//!     <img src="../static/ridged.png" alt="RidgedMultifractalNoise">
//! </div>
//!
//! From left to right: [PinkNoise](./struct.PinkNoise.html), [BillowNoise]
//! (./struct.PinkNoise.html), [RidgedMultifractalNoise]
//! (./struct.RidgedMultifractalNoise.html).
//!
//! Fractal noise types implement the standard library's `Default` and `Rand`
//! traits to ease in their creation. The former will fill in the fields with
//! sensible defaults and a seed of zero, while the latter will randomize *only*
//! the seed value. The following is a common way to set specific or random
//! seed values:
//!
//! ```rust
//! use std::default::Default;
//! use std::rand::{Rand, task_rng};
//!
//! use grunge::fractal::{PinkNoise, BillowNoise};
//!
//! let mut rng = task_rng();
//!
//! let pink = PinkNoise { seed: 1035, octaves: 4, .. Default::default() };
//! let billow: BillowNoise = Rand::rand(&mut rng);
//! ```

use std::default::Default;
use std::rand::{Rand, Rng};
use cgmath::vector::{Vector, Vector2};

use primitives::{snoise_2d, NoiseModule};
use modifiers::Modifiable;

static PINKNOISE_SCALE: f32 = 0.25;
static BILLOWNOISE_SCALE: f32 = 0.25;
static RMULTINOISE_SCALE: f32 = 0.28;

/// PinkNoise is generated by calculating the contribution of a number of
/// individual `octaves` of noise samples, and then adding them together.
/// PinkNoise is a kind of fractal noise, because the contributions are self-
/// similar.
///
/// Its output takes the form
///
/// $$M(\mathbf{x}) = p N(f \mathbf{x}) + p\^2 N(fl \mathbf{x}) + \ldots +
///     p\^n N(fl\^{n - 1} \mathbf{x})$$
///
/// where $p, f, l$ are persistence, frequency, and lacunarity, respectively,
/// $N$ is the noise function, and $\mathbf{x}$ is the vector of input
/// coordinates.
#[deriving(Clone)]
pub struct PinkNoise {
    /// The "seed" used to ensure reproducibility and variation in the output of
    /// the module.
    pub seed: uint,

    /// The scale of the noise. Setting this value is equivalent to scaling all
    /// input coordinates by the same value.
    pub frequency: f32,

    /// The apparent "roughness" of the noise. This value controls the amplitude
    /// falloff of the successive octaves, so that `0.5` will scale the first
    /// octave by `1.0`, the second by `0.5`, the third by `0.25`, and so on.
    pub persistence: f32,

    /// The frequency multiplier between successive octaves.
    pub lacunarity: f32,

    /// The number of octaves is the number of successive additive samples of
    /// the noise function this module will use to generate output. It is
    /// essentially a measure of the level of "detail" in the output.
    pub octaves: uint
}

impl PinkNoise {
    /// Create a new object with the seed `seed` and all parameters set to their
    /// default values.
    pub fn new(seed: uint) -> PinkNoise {
        PinkNoise { seed: seed, .. Default::default() }
    }
}

impl Default for PinkNoise {
    fn default() -> PinkNoise {
        PinkNoise {
            seed: 0, frequency: 1.0, persistence: 0.5,
            lacunarity: 2.0, octaves: 6
        }
    }
}

impl Rand for PinkNoise {
    fn rand<R: Rng>(rng: &mut R) -> PinkNoise {
        PinkNoise { seed: rng.gen(), .. Default::default() }
    }
}

impl NoiseModule for PinkNoise {
    fn generate_2d(&self, v: Vector2<f32>) -> Result<f32, &str> {
        if self.octaves <= 1 {
            return Err("The number of octaves must be two or greater.");
        } else if self.octaves > 30 {
            return Err("The number of octaves must be less than 30.");
        }

        let mut result: f32 = 0.0;
        let mut sample = Vector2 {
            x: v.x * self.frequency, y: v.y * self.frequency
        };
        let mut persistence = 1.0;

        for octave in range(0, self.octaves) {
            result += persistence * snoise_2d(sample, self.seed + octave);
            sample = Vector2 {
                x: sample.x * self.lacunarity, y: sample.y * self.lacunarity
            };
            persistence *= self.persistence;
        }

        Ok(result * PINKNOISE_SCALE)
    }
}

impl Modifiable for PinkNoise {}

/// BillowNoise is quite smilar to PinkNoise, but uses the absolute value of the
/// noise function to create a more puffy, cloud-like appearance.
#[deriving(Clone)]
pub struct BillowNoise {
    /// The "seed" used to ensure reproducibility and variation in the output of
    /// the module.
    pub seed: uint,

    /// The scale of the noise. Setting this value is equivalent to scaling all
    /// input coordinates by the same value.
    pub frequency: f32,

    /// The apparent "roughness" of the noise. This value controls the amplitude
    /// falloff of the successive octaves, so that `0.5` will scale the first
    /// octave by `1.0`, the second by `0.5`, the third by `0.25`, and so on.
    pub persistence: f32,

    /// The frequency multiplier between successive octaves.
    pub lacunarity: f32,

    /// The number of octaves is the number of successive additive samples of
    /// the noise function this module will use to generate output. It is
    ///  essentially a measure of the level of "detail" in the output.
    pub octaves: uint,

    /// The offset from zero, used to reduce visual artifacts when using the
    /// absolute value function.
    pub offset: f32
}

impl BillowNoise {
    /// Create a new object with the seed `seed` and all parameters set to their
    /// default values.
    pub fn new(seed: uint) -> BillowNoise {
        BillowNoise { seed: seed, .. Default::default() }
    }
}

impl Default for BillowNoise {
    fn default() -> BillowNoise {
        BillowNoise {
            seed: 0, frequency: 1.0, persistence: 0.5,
            lacunarity: 2.0, offset: 0.2, octaves: 6
        }
    }
}

impl Rand for BillowNoise {
    fn rand<R: Rng>(rng: &mut R) -> BillowNoise {
        BillowNoise { seed: rng.gen(), .. Default::default() }
    }
}

impl NoiseModule for BillowNoise {
    fn generate_2d(&self, v: Vector2<f32>) -> Result<f32, &str> {
        if self.octaves <= 1 {
            return Err("The number of octaves must be two or greater.");
        } else if self.octaves > 30 {
            return Err("The number of octaves must be less than 30.");
        }

        let mut result: f32 = 0.0;
        let mut sample = Vector2 {
            x: v.x * self.frequency, y: v.y * self.frequency
        };
        let mut persistence = 1.0;

        for octave in range(0, self.octaves) {
            result += persistence *
                (snoise_2d(sample, self.seed + octave) + self.offset).abs();
            sample = Vector2 {
                x: sample.x * self.lacunarity, y: sample.y * self.lacunarity
            };
            persistence *= self.persistence;
        }

        Ok(result * BILLOWNOISE_SCALE * 2.0 - 1.0)
    }
}

impl Modifiable for BillowNoise {}

/// RidgedMultifractalNoise uses the square of the absolute value of the noise
/// function to achieve ridge-like effects, and weights contributions by the
/// previous octave's output. This has the effect of further polarising the
/// result.
///
/// This implementation is based on the one given by its inventor F. Kenton
/// Musgrave [1] in the C programming language, although it has been adapted to
/// fit with the library.
///
/// 1. Musgrave's original website is gone, but the code is available [here]
///    (https://engineering.purdue.edu/~ebertd/texture/1stEdition/musgrave/musgrave.c).
#[deriving(Clone)]
pub struct RidgedMultifractalNoise {
    /// The "seed" used to ensure reproducibility and variation in the output of
    /// the module.
    pub seed: uint,

    /// The scale of the noise. Setting this value is equivalent to scaling all
    /// input coordinates by the same value.
    pub frequency: f32,

    /// The frequency multiplier between successive octaves.
    pub lacunarity: f32,

    /// The number of octaves is the number of successive additive samples of
    /// the noise function this module will use to generate output. It is
    ///  essentially a measure of the level of "detail" in the output.
    pub octaves: uint,

    /// The offset from zero, used to reduce visual artifacts when using the
    /// absolute value function.
    pub offset: f32,

    /// The exponent multiplier. This is used to calculate what Musgrave calls
    /// 'spectral weights'.
    pub power: f32,

    /// The contribution of each successive octave to the weighting of the next.
    pub gain: f32
}

impl RidgedMultifractalNoise {
    /// Create a new object with the seed `seed` and all parameters set to their
    /// default values.
    pub fn new(seed: uint) -> RidgedMultifractalNoise {
        RidgedMultifractalNoise { seed: seed, .. Default::default() }
    }
}

impl Default for RidgedMultifractalNoise {
    fn default() -> RidgedMultifractalNoise {
        RidgedMultifractalNoise {
            seed: 0, frequency: 1.0, lacunarity: 2.0,
            offset: 1.0, power: -1.0, gain: 2.0, octaves: 10
        }
    }
}

impl Rand for RidgedMultifractalNoise {
    fn rand<R: Rng>(rng: &mut R) -> RidgedMultifractalNoise {
        RidgedMultifractalNoise { seed: rng.gen(), .. Default::default() }
    }
}

impl NoiseModule for RidgedMultifractalNoise {
    fn generate_2d(&self, v: Vector2<f32>) -> Result<f32, &str> {
        if self.octaves <= 1 {
            return Err("The number of octaves must be two or greater.");
        } else if self.octaves > 30 {
            return Err("The number of octaves must be less than 30.");
        }

        let mut sample = v.mul_s(self.frequency);

        // Start with the default noise and weight values
        let mut result: f32 = 0.0;
        let mut weight = 1.0;

        for octave in range(0, self.octaves) {
            let mut signal = self.offset - RMULTINOISE_SCALE * snoise_2d(sample, self.seed + octave).abs();
            signal *= signal * weight;

            result += signal * self.lacunarity.powf(octave as f32).powf(self.power);

            // Shift sample
            sample = sample.mul_s(self.lacunarity);

            // Set weights for the next iteration
            weight = signal * self.gain;
            weight = if weight > 1.0 { 1.0 } else if weight < 0.0 { 0.0 } else { weight };
        }

        Ok(result * 1.25 - 1.0)
    }
}

impl Modifiable for RidgedMultifractalNoise {}
